MQ(消息队列）是在消息的传输过程中保存消息的容器，当大批用户同时发送请求的时候，容易超过后端服务器的处理限制，这时需要一个容器来储存消息。这种发布-订阅的模式有以下好处：
 + 应用解耦：消费者和生产者互不干涉，可以独立扩展，只需遵守同样的接口设计，例如用nodejs实现生产者，java实现消费者。
 + 峰值处理：提供一个管理机制来处理请求超过服务器限制带来的负载崩溃，可以限制生产者进入队列的速度来防止超过消费者的处理上限
 + 排序保证：数据结构队列先进先出的机制保证了排序
 + 可扩展性：可以针对中间件的配置进行修改，来适应更多的场景。


## Rabbitmq
由 Erlang（有着和原生 Socket 一样低的延迟）语言开发的基于 AMQP 协议的开源消息队列系统，对分布式设计有着很好的支持。此外他也支持多种协议如AMQP, MQTT, STOMP, 这种特性也让他可以适用于更多的场景。

## Kafka
是由 Apache 软件基金会开发的一个开源流处理平台，由 Scala 和 Java 编写，是一种高吞吐量的分布式发布订阅消息系统，支持单机每秒百万并发。另外，Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件。Kafka 使用自定义协议，在 TCP/IP 之上进行应用程序和集群之间的通信。 Kafka 不能简单地删除和替换，因为它是唯一实现该协议的软件。

## 总结
这两个队列中间件都可以实现消息延迟的处理，需要针对实际情况进行选择。该项目需要实现订单延迟支付功能，可以用传统的发布-订阅模式解决，通过直接处理队列间的通信实现延迟。rabbitmq 适用于长时间运行和需要可靠后台的任务，作为微服务的中间人，通知系统另一部分开始处理任务，非常适合订单处理的场景。此外Rabbitmq的扩展性更好，用nodejs的改写会更方便，该项目使用单点模式，吞吐量不会太大，所以该项目选择Rabbitmq来实现。
